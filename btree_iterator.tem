#include "btree_iterator.h"
 
template <typename T>
T& btree_iterator<T>::operator*() const{
  return _pTree->_vec[_index].first;
}
template <typename T>
T* btree_iterator<T>::operator->() const{
  return &_pTree->_vec[_index].first;
}
template <typename T>
btree_iterator<T>& btree_iterator<T>::operator++() {
  return this;
}
template <typename T>
bool btree_iterator<T>::operator==(const btree_iterator<T>& other){
  if( this->_pTree == nullptr && other._pTree == nullptr){
    return true;
  }else if( this->_pTree == other._pTree && this->_index == other._index){
    return true;
  }
  return false;
}
template <typename T>
bool btree_iterator<T>::operator!=(const btree_iterator<T>& other){
  return !this==(other);
}
template <typename T>
btree_iterator<T>::btree_iterator( btree<T>* pTree, size_t index): _pTree(pTree), _index(index){
}

/**
  *
  * const iterator
  *
  */

template <typename T>
const T& const_btree_iterator<T>::operator*() const{
  return holder;
}
// TODO write const T* as typedef pointer
template <typename T>
const T* const_btree_iterator<T>::operator->() const{
  return &holder;
}
template <typename T>
const_btree_iterator<T>& const_btree_iterator<T>::operator++() {
  return this;
}
template <typename T>
bool const_btree_iterator<T>::operator==(const const_btree_iterator<T>& other){
  return true;
}
template <typename T>
bool const_btree_iterator<T>::operator!=(const const_btree_iterator<T>& other){
  return true;
}
template <typename T>
const_btree_iterator<T>::const_btree_iterator( btree<T>* pointee): _pointee(pointee){
}
