// your btree implementation goes here
#include "btree.h"
#include "btree_iterator.h"
#include <iostream>
#include <iterator>
#include <deque>
using namespace std;

template<typename T>
btree<T>::btree(size_t maxNodeElems): _maxNodeElems(maxNodeElems), _parent(nullptr),_last(nullptr) { }
template<typename T>
btree<T>::btree(size_t maxNodeElems, btree<T>* parent): _maxNodeElems(maxNodeElems), _parent(parent),
_last(nullptr) { }

// copy ctor
// Only pass the root btree as argument
// only guarantee to work correctly if original is correct
template<typename T>
btree<T>::btree(const btree<T>& original){
  this->_maxNodeElems = original._maxNodeElems;
  deque<const btree<T> *> q;
  q.push_back(&original);
  while( !q.empty() ){
    const btree<T> *t = q[0];
    q.pop_front();
    for( auto p: t->_vec){
      if( ! p.second->isEmpty() ){
        q.push_back( p.second );
      }
    }
    if( t-> _last != nullptr){
      q.push_back( t->_last );
    }
    for( auto p: t->_vec){
      this->insert(p.first);
    }
  }

}

// move ctor
// Only pass the root btree as argument
template<typename T>
btree<T>::btree( btree<T>&& original){
  this->_maxNodeElems = original._maxNodeElems;
  this->_vec = move(original._vec);
  this->_last = original._last;

  original._last = nullptr;

}

template<typename T>
btree<T>& btree<T>::operator=(const btree<T>& rhs){
  // TODO destroy elements in this->_vec properly
  this->_vec = move(rhs._vec);
  this->_last = rhs._last;

  btree<T> temp(rhs);
  // TODO guarantee this uses btree:swap
  swap( *this, temp);
  
  return *this;
}

template<typename T>
btree<T>& btree<T>::operator=(btree<T>&& rhs){
  swap(*this,rhs);
  // TODO cleanup rhs
  return *this;
}

template<typename T>
std::ostream& operator<< (std::ostream& os, const btree<T>& tree){
  deque<const btree<T> *> q;
  q.push_back(&tree);
  while( !q.empty()  ){

    const btree<T> *t = q[0];
    q.pop_front();
    if( t == nullptr){
    }

    //copy over next depth
    for(auto p: t->_vec){
      if(! p.second->isEmpty()) {
        q.push_back(p.second);
      }
    }
    if( t-> _last != nullptr ){
       q.push_back(t->_last );
    }

    for( size_t i=0; i< t->_vec.size(); ++i){
      cout << t->_vec[i].first;
        if( q.empty() && i+1 == t->_vec.size()){
          continue;
        }
        cout << " ";
    }
  }

  return os;
}

template<typename T>
btree_iterator<T> btree<T>::find( const T& elem){
  return btree_iterator<T>(nullptr, nullptr);
}
template<typename T>
const_btree_iterator<T> btree<T>::find( const T& elem)const{
  return const_btree_iterator<T>();
}
template<typename T>
std::pair<btree_iterator<T>, bool> btree<T>::insert(const T& elem){
  if( this-> isFull() ){
    for(size_t i = 0; i<_maxNodeElems; ++i){
      // element already exists
      if( elem == _vec[i].first){
        // TODO return proper iterator
        return make_pair< btree_iterator<T>,bool>(btree_iterator<T>(), false);
      }
      // element is in another btree
      if( elem < _vec[i].first  ){
        return _vec[i].second->insert(elem);
      }

    }
    // element is larger send it to the larger branch
    return _last->insert(elem);
  }else{
    for( size_t i=0; i< _vec.size(); ++i ){
      // element already exists
      if( _vec[i].first == elem ){
        // TODO return proper iterator
        return make_pair< btree_iterator<T>,bool>(btree_iterator<T>(), false);
        // element should be inserted here
      }else if( elem < _vec[i].first  ){
        _vec.insert(_vec.begin()+i, make_pair(elem, new btree<T>(_maxNodeElems, this)));
        // if it's saturated add extra last node
        if( _vec.size() >= _maxNodeElems )
          _last = new btree(_maxNodeElems, this);
        // TODO return proper iterator
        return make_pair< btree_iterator<T>,bool>(btree_iterator<T>(), false);
      }
    }
    // found no place to insert thus it must be at the end
    _vec.push_back(make_pair( elem, new btree<T>( _maxNodeElems, this)));
    // if it's saturated add extra last node
    if( _vec.size() >= _maxNodeElems ){
      _last = new btree(_maxNodeElems);
    }
    return make_pair< btree_iterator<T>,bool>(btree_iterator<T>(), true);
  }
}
template<typename T>
std::pair<const_btree_iterator<T>, bool> btree<T>::insert(const T& elem)const{
  return make_pair< const_btree_iterator<T>,bool>(const_btree_iterator<T>(), true);
}
template<typename T>
btree<T>::~btree(){
  if( _last != nullptr){
    delete _last;
  }
  for( auto& p: _vec){
    delete p.second;
    p.second = nullptr;
  }
  _parent = nullptr;
}
// private functions
template<typename T>
btree<T>* btree<T>::getPrevious( btree<T>* tree, const T& elem){
}

template<typename T>
void btree<T>::swap( btree<T>& lhs, btree<T>& rhs){
  swap(lhs._maxNodeElems , rhs._maxNodeElems);
  lhs._vec = move(rhs._vec);
  swap(lhs._last , rhs._last);

}
