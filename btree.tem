// your btree implementation goes here
#include "btree.h"
#include "btree_iterator.h"
#include <iostream>
#include <iterator>
#include <deque>
using namespace std;

template<typename T>
btree<T>::btree(size_t maxNodeElems): _maxNodeElems(maxNodeElems), _parent(nullptr){ }

template<typename T>
btree<T>::btree(const btree<T>& original){
  // clear out the old stuff
  this->_map.clear();
  this->_parent = nullptr;

  // breadth first search insertion
  // if the btree is in a valid state it should create a valid copy
  this->_maxNodeElems = original._maxNodeElems;
  deque<pair<T, btree<T>*>> queue;
  copy( original._map.begin(), original._map.end(), back_inserter(queue));
  while( queue.size() > 0){
    pair<T, btree<T>*> tuple = queue[0];
    queue.pop_front();
    copy(tuple.second->_map.begin(), tuple.second->_map.end(), back_inserter(queue));
    this-> insert( tuple.first);
  }

}

// move ctor
template<typename T>
btree<T>::btree( btree<T>&& original){
  this->_maxNodeElems = original._maxNodeElems;
  this->_map = move(original._map);

}

template<typename T>
btree<T>& btree<T>::operator=(const btree<T>& rhs){
  btree<T> treeTemp(rhs);
  steal(*this, treeTemp);
  return *this;
}


template<typename T>
btree<T>& btree<T>::operator=(btree<T>&& rhs){
  steal(*this,rhs);
  return *this;
}

template<typename T>
std::ostream& operator<< (std::ostream& os, const btree<T>& tree){
  deque<pair<T, btree<T>*>> queue;

  copy(tree._map.begin(), tree._map.end(),back_inserter(queue));
  cout << "size queue " << queue.size() << endl;
  cout << "size tree " << tree._map.size() << endl;

  while( queue.size() >0 ){
    pair<T, btree<T>*> tuple = queue[0];
    queue.pop_front();
    copy(tuple.second->_map.begin(), tuple.second->_map.end(),back_inserter(queue));
    cout << "elem " << tuple.first << endl;
  }
  cout << "tree" << endl;
  return os;
}

template<typename T>
btree_iterator<T> btree<T>::find( const T& elem){
  btree<T>* treeCur = this;
  while( !treeCur->isEmpty() ){
    auto it = treeCur->_map.lower_bound(elem);
    if( it->first == elem){
      return btree_iterator<T> (treeCur, getPrevious(treeCur, elem));
    }
    // special case here, _map end falls inte last pairs jurisdiction
    if( it == treeCur->_map.end() ){
      // TODO precedence gamble here expected (--it)->second;
      treeCur = --it->second;
    }else{
      treeCur = it->second;
    }
  }
  // didnt find the element -> return iterator(nullptr)
  return btree_iterator<T>(nullptr, nullptr);
}
template<typename T>
const_btree_iterator<T> btree<T>::find( const T& elem)const{
  return const_btree_iterator<T>();
}
template<typename T>
std::pair<btree_iterator<T>, bool> btree<T>::insert(const T& elem){
  btree<T>* treeCur = this;
  while( treeCur->isFull() ){
    auto it_map = treeCur->_map.lower_bound(elem);
    // if tree is full and elem exist -> return false
    if( it_map->first == elem){
      // TODO return proper iterator
      return make_pair< btree_iterator<T>,bool>(btree_iterator<T>(), false);
      // If tree is full and elem is larger than all elem in _map -> get last tree in map
    }else if( it_map == treeCur->_map.end()){
      --it_map;
      treeCur = it_map->second;
      // if tree is full and elem doesnt exist -> get next tree
    }else{
      treeCur = it_map->second;
    }
  }
  auto it_map = treeCur->_map.lower_bound(elem);
  // if tree is not full and elem exist -> return false
  if( it_map-> first == elem ){
    // TODO return proper iterator
    return make_pair< btree_iterator<T>,bool>(btree_iterator<T>(), false);
  }
  // if tree is not full and elem doesnt exist -> insert tree
  btree<T>* treeTemp = new btree<T>();
  treeTemp->_parent = treeCur;
  treeCur->_map.emplace(elem,treeTemp);
  return make_pair< btree_iterator<T>,bool>(btree_iterator<T>(), true);
}
template<typename T>
std::pair<const_btree_iterator<T>, bool> btree<T>::insert(const T& elem)const{
  return make_pair< const_btree_iterator<T>,bool>(const_btree_iterator<T>(), true);
}
template<typename T>
btree<T>::~btree(){
}
// private functions
template<typename T>
bool btree<T>::isFull(){
  return _map.size() >= _maxNodeElems;
}
template<typename T>
void btree<T>::steal(btree<T>& lhs, btree<T>& rhs){
  lhs._maxNodeElems = rhs._maxNodeElems;
  lhs._map = move(rhs._map);
}
template<typename T>
btree<T>* btree<T>::getPrevious( btree<T>* tree, const T& elem){
  auto it = tree->_map.lower_bound( elem );
  if( it == tree->_map.begin() ){
    return tree->_parent;
  }else{
    --it;
    return it->second;
  }

}
