// your btree implementation goes here
#include "btree.h"
#include "btree_iterator.h"
#include <iostream>
#include <iterator>
#include <deque>
using namespace std;

template<typename T>
btree<T>::btree(size_t maxNodeElems): _maxNodeElems(maxNodeElems), _parent(nullptr),_last(nullptr) { }
template<typename T>
btree<T>::btree(size_t maxNodeElems, btree<T>* parent): _maxNodeElems(maxNodeElems), _parent(parent),
_last(nullptr) { }

// copy ctor
// Only pass the root btree as argument
// only guarantee to work correctly if original is correct
template<typename T>
btree<T>::btree(const btree<T>& original): _maxNodeElems(original._maxNodeElems),_parent(nullptr),_last(nullptr){
  deque<const btree<T> *> q;
  q.push_back(&original);
  while( !q.empty() ){
    const btree<T> *t = q[0];
    q.pop_front();
    for( auto p: t->_vec){
      if( ! p.second->isEmpty() ){
        q.push_back( p.second );
      }
    }
    if( t-> _last != nullptr){
      q.push_back( t->_last );
    }
    for( auto p: t->_vec){
      this->insert(p.first);
    }
  }

}

// move ctor
// Only pass the root btree as argument
template<typename T>
btree<T>::btree( btree<T>&& original): _parent(nullptr),_vec(move(original._vec)){
  this->_maxNodeElems = original._maxNodeElems;
//  this->_vec = move(original._vec);
  this->_last = original._last;

  original._last = nullptr;

}

template<typename T>
btree<T>& btree<T>::operator=(const btree<T>& rhs){
  btree<T> temp(rhs);
  swap( *this, temp);
  return *this;
}

template<typename T>
btree<T>& btree<T>::operator=(btree<T>&& rhs){
  swap(*this,rhs);
  btree<T> temp(*this._maxNodeElems);
  swap(temp,rhs);
  if(this->_last != nullptr){
    this->_last->_parent=this;
  }
  return *this;
}

template<typename T>
std::ostream& operator<< (std::ostream& os, const btree<T>& tree){
  deque<const btree<T> *> q;
  q.push_back(&tree);
  while( !q.empty()  ){

    const btree<T> *t = q[0];
    q.pop_front();
    if( t == nullptr){
    }

    //copy over next depth
    for(auto p: t->_vec){
      if(! p.second->isEmpty()) {
        q.push_back(p.second);
      }
    }
    if( t-> _last != nullptr ){
       q.push_back(t->_last );
    }

    for( size_t i=0; i< t->_vec.size(); ++i){
      cout << t->_vec[i].first;
      if( t->_parent == nullptr){
        cout << " _parent is null" <<endl;
      }
        if( q.empty() && i+1 == t->_vec.size()){
          continue;
        }
        cout << " ";
    }
  }

  return os;
}

template<typename T>
btree_iterator<T> btree<T>::find( const T& elem){
  for(size_t i=0; i< this->_vec.size(); ++i){
    if( elem < this->_vec[i].first && this->_vec[i].second->isEmpty()){
      cout << "cant find elem" << endl;
      return btree_iterator<T>(nullptr,0);
    } else if( elem < this->_vec[i].first ){
      return this->_vec[i].second->find(elem);
    }else if( elem == this->_vec[i].first ){
      cout << "find suceeded" << endl;
      return btree_iterator<T>(this,i);
    }
  }
  if( this->_last == nullptr ){
      cout << "cant find elem" << endl;
    return btree_iterator<T>(nullptr,0);
  }
  return this->_last->find(elem);
}
// TODO can you abstract the other find?
template<typename T>
const_btree_iterator<T> btree<T>::find( const T& elem)const{
  return const_btree_iterator<T>();
}
template<typename T>
std::pair<btree_iterator<T>, bool> btree<T>::insert(const T& elem){
  if( this-> isFull() ){
    for(size_t i = 0; i<_maxNodeElems; ++i){
      // element already exists
      if( elem == _vec[i].first){
        // TODO return proper iterator
        return make_pair< btree_iterator<T>,bool>(btree_iterator<T>(this,i), false);
      }
      // element is in another btree
      if( elem < _vec[i].first  ){
        return _vec[i].second->insert(elem);
      }
    }
    // element is larger send it to the larger branch
    return _last->insert(elem);
  }else{
    for( size_t i=0; i< _vec.size(); ++i ){
      // element already exists
      if( _vec[i].first == elem ){
        // TODO return proper iterator
        return make_pair< btree_iterator<T>,bool>(btree_iterator<T>(this,i), false);
        // element should be inserted here
      }else if( elem < _vec[i].first  ){
        cout << "elem was inserted: " << elem << endl;
        _vec.insert(_vec.begin()+i, make_pair(elem, new btree<T>(_maxNodeElems, this)));
        // if it's saturated add extra last node
        if( _vec.size() >= _maxNodeElems )
          _last = new btree(_maxNodeElems, this);
        // TODO return proper iterator
        return make_pair< btree_iterator<T>,bool>(btree_iterator<T>(this,i), false);
      }
    }
    cout << "elem was inserted at back: " << elem << endl;
    // found no place to insert thus it must be at the end
    _vec.push_back(make_pair( elem, new btree<T>( _maxNodeElems, this)));
    // if it's saturated add extra last node
    if( _vec.size() >= _maxNodeElems ){
      cout << "  elem got _last node: " << elem <<endl;
      _last = new btree(_maxNodeElems,this);
      if(_last->_parent ==this ) {
        cout << "  Added parent correctly"<<endl;
      }else{
        cout << "  Fail parent correctly"<<endl;
      }
    }

    return make_pair< btree_iterator<T>,bool>(btree_iterator<T>(this,_vec.size()-1), true);
  }
}
// TODO can you abstract the other insert
template<typename T>
std::pair<const_btree_iterator<T>, bool> btree<T>::insert(const T& elem)const{
  return make_pair< const_btree_iterator<T>,bool>(const_btree_iterator<T>(), true);
}
template<typename T>
btree<T>::~btree(){
  if( _last != nullptr){
    delete _last;
  }
  for( auto& p: _vec){
    delete p.second;
    p.second = nullptr;
  }
  _parent = nullptr;
}
// private functions
template<typename T>
bool btree<T>::integrity(btree<T>* father){
  cout << "integrity check "<<endl;
  bool res = (this->_parent == father);
  if(!res){
      cout<< "father: " <<father<<endl;
      cout<< "parent: " <<_parent<<endl;
    cout << "You are not my father"<<endl;
    return false;
  }
  for(auto p: this->_vec){
    if(! p.second->integrity(this)){
      cout<< "integrity error on elem " << p.first <<endl;
      return false;
    }
  }
  if( _last != nullptr ){
    return _last->integrity(this);
  }
  return true;
}

template<typename T>
void btree<T>::swap( btree<T>& lhs, btree<T>& rhs){
  swap(lhs._maxNodeElems , rhs._maxNodeElems);
  lhs._vec = move(rhs._vec);
  swap(lhs._last , rhs._last);

}
